<style>
  h1, h2, h3 { font-family: sans-serif; }
  pre code {
    display: block;
    background-color: #f5f5f5;
    color: #222;
    padding: 1rem;
    border-radius: 6px;
    overflow-x: auto;
    font-family: Consolas, monospace;
  }
</style>

<h1 id="securite">Chapitre 3 â€“ SÃ©curisation des paiements & Webhooks</h1>

<p>
Chaque paiement Stripe dÃ©clenche une cascade d'Ã©vÃ©nements asynchrones : confirmation, remboursement, Ã©chec, litige.  
Ces Ã©vÃ©nements sont transmis Ã  votre backend via des <strong>webhooks</strong>.  
Mais sans protection, nâ€™importe qui pourrait simuler un webhook Stripe et accÃ©der Ã  des actions sensibles.
</p>

---

<h2 id="risques">1. Menaces courantes sur les webhooks</h2>

<ul>
  <li>ğŸš¨ RequÃªtes falsifiÃ©es : simulation dâ€™un paiement par un tiers</li>
  <li>ğŸš¨ Replays : envoi plusieurs fois dâ€™un ancien webhook</li>
  <li>ğŸš¨ Modification du corps JSON pendant le transport</li>
  <li>ğŸš¨ Injections et falsifications dâ€™authentification</li>
</ul>

---

<h2 id="signature">2. VÃ©rification de la signature Stripe</h2>

<p>
Stripe signe chaque webhook avec un secret partagÃ© que vous seul connaissez.  
Vous devez :
</p>

<ol>
  <li>Extraire l'en-tÃªte <code>Stripe-Signature</code></li>
  <li>RÃ©cupÃ©rer le timestamp et le hash HMAC</li>
  <li>Recalculer la signature avec votre secret</li>
  <li>Comparer les deux avec un <strong>secure compare</strong></li>
</ol>

<pre><code class="language-python">
import hmac, hashlib

payload = raw_request_body
secret = os.getenv("STRIPE_WEBHOOK_SECRET")
timestamp = headers["Stripe-Signature"].split(",")[0].split("=")[1]
signature = headers["Stripe-Signature"].split(",")[1].split("=")[1]

signed_payload = f"{timestamp}.{payload}"
expected = hmac.new(
    secret.encode(), signed_payload.encode(), hashlib.sha256
).hexdigest()

if not secure_compare(signature, expected):
    abort(403)
</code></pre>

---

<h2 id="replay">3. Protection contre les replays</h2>

<p>
Un attaquant peut capturer une requÃªte Stripe et la rejouer plus tard.  
Pour Ã©viter cela, Stripe ajoute un <strong>timestamp</strong> dans la signature. Vous devez :
</p>

<ul>
  <li>Rejeter toute signature dont le timestamp a plus de 5 minutes</li>
  <li>Stocker les IDs dâ€™Ã©vÃ©nements dÃ©jÃ  traitÃ©s (idempotence webhook)</li>
</ul>

---

<h2 id="bonnespratiques">4. Bonnes pratiques supplÃ©mentaires</h2>

<ul>
  <li>Utiliser HTTPS obligatoirement</li>
  <li>Limiter les IP ou rÃ©gions autorisÃ©es si possible</li>
  <li>Ne jamais faire confiance Ã  un champ comme <code>event["type"]</code> sans signature</li>
  <li>Consommer les Ã©vÃ©nements avec <strong>ACK explicites</strong></li>
</ul>

---

<h2 id="conclusion">5. Conclusion</h2>

<blockquote>
<strong>Les webhooks sont lâ€™un des vecteurs dâ€™attaque les plus nÃ©gligÃ©s.</strong>  
Stripe vous fournit tous les outils pour sÃ©curiser leur traitement. Ã€ vous de les implÃ©menter strictement.
</blockquote>

<p>
Dans tout systÃ¨me financier, lâ€™intÃ©gritÃ© des Ã©vÃ©nements dÃ©clenchÃ©s doit Ãªtre garantie cryptographiquement.  
Cela sâ€™applique aussi bien Ã  Stripe quâ€™Ã  toute autre API de paiement.
</p>

---

<h2 id="exercice">ğŸ“ Exercice</h2>

<p>
1. CrÃ©e un endpoint <code>POST /webhook</code> avec les Ã©lÃ©ments suivants :
</p>

<ul>
  <li>Lecture brute du corps de la requÃªte</li>
  <li>Extraction de lâ€™en-tÃªte <code>Stripe-Signature</code></li>
  <li>VÃ©rification HMAC avec timestamp</li>
  <li>Refus des requÃªtes expirÃ©es ou falsifiÃ©es</li>
  <li>Journalisation dans un fichier sÃ©curisÃ©</li>
</ul>

<p>
Optionnel : simule une attaque (replay, faux payload, modification de type).
</p>
